// Generated by dts-bundle-generator v7.1.0

/**
 * Clone a value and all of its nested values.
 *
 * This produces a deep clone of a given value.
 *
 * @param {T} value The value to clone.
 * @returns {T} The cloned value.
 */
export declare const clone: <T>(value: T) => T;
/**
 * Return an array of key/value tuples for an object.
 *
 * @param {Readonly<Record<K, V>>} obj The object for which the values are
 * to be returned.
 * @returns {Array<[K, V]>} An array of key/value tuples for the object.
 */
export declare function entries<K extends string, V>(obj: Readonly<Record<K, V>>): Array<[
	K,
	V
]>;
/**
 * Return an array of the enumerable keys of an object.
 *
 * @param {Readonly<Record<string, unknown>>} obj The object for which the values are
 * to be returned.
 * @returns {Array<$Keys<O>>} An array of the enumerable keys of an object.
 */
export declare function keys<O extends Record<string, unknown>>(obj: Readonly<O>): Array<keyof O>;
/**
 * Return an array of the enumerable property values of an object.
 *
 * @param {ReadOnly<Record<unknown, V>>} obj The object for which the values are
 * to be returned.
 * @returns {Array<V>} An array of the enumerable property values of the object.
 */
export declare function values<V>(obj: Readonly<Record<keyof any, V>>): Array<V>;
/**
 * @typedef {Object} Errors A base error taxonomy for consumers of this core
 * library to build off.
 *
 * @property {string} Unknown The kind of error is not known.
 * @property {string} Internal The error is internal to the executing code.
 * @property {string} InvalidInput There was a problem with the provided input,
 * such as the wrong format or a null value.
 * @property {string} InvalidUse The error is down an improper use of the
 * invoked code.
 */
/**
 * @type {Errors} A base error taxonomy.
 */
export declare const Errors: Readonly<{
	Unknown: "Unknown";
	Internal: "Internal";
	InvalidInput: "InvalidInput";
	InvalidUse: "InvalidUse";
}>;
export declare const Order: Readonly<{
	ConsequenceFirst: "consequence-first";
	CauseFirst: "cause-first";
}>;
export type SequenceOrder = typeof Order[keyof typeof Order];
/**
 * Given an error, generates a sequence of `Error`s.
 *
 * If the given error is a `KindError`-derivitive, this function will return
 * a sequence starting with that error and then including any causal errors,
 * chaining through causal `KindError`s accordingly.
 *
 * If `reverse` is `true`, the generated sequence starts with the lowermost
 * causal error and ends with the given error.
 */
export declare function errorsFromError(error: Error | null | undefined, order: SequenceOrder): Iterator<Error>;
/**
 * Get the kind for the given error.
 */
export declare const getKindFromError: (error: Error) => string;
/**
 * Get the original stack trace for the given error.
 */
export declare const getOriginalStackFromError: (error: Error) => string;
export type MetadataPrimitive = string | number | boolean | null | undefined;
export type MetadataArray<T> = Array<T | MetadataArray<T>>;
/**
 * A collection of data.
 */
export type Metadata = {
	[name: string]: Metadata | MetadataPrimitive | MetadataArray<MetadataPrimitive | Metadata>;
};
/**
 * Options for constructing a `KindError`.
 */
export type Options = {
	/**
	 * An error responsible for the error being created.
	 *
	 * @type {?Error}
	 */
	cause?: Error | null | undefined;
	/**
	 * Data to be attached to the error.
	 *
	 * @type {?Metadata}
	 */
	metadata?: Metadata | null | undefined;
	/**
	 * A prefix for the error name.
	 *
	 * @type {?string}
	 */
	prefix?: string | null | undefined;
	/**
	 * A name for the error.
	 *
	 * @type {?string}
	 */
	name?: string | null | undefined;
	/**
	 * The number of stack frames to strip from the error.
	 *
	 * @type {?number}
	 */
	stripStackFrames?: number | null | undefined;
	/**
	 * The minimum number of stack frames to try and retain.
	 *
	 * @type {?number}
	 */
	minimumFrameCount?: number | null | undefined;
	/**
	 * Should we create a composite stack from the causal error chain or not?
	 *
	 * @type {?boolean}
	 */
	compositeStack?: boolean | null | undefined;
};
/**
 * An error to describe detailed states and relationships.
 *
 * This error type supports error taxonomies and attachment of metadata, as
 * well as causal relationships between itself and another source error.
 * More specific variations can be built off this to provide a payload for
 * logging setups like Sentry or winston.
 */
export declare class KindError extends Error {
	readonly kind: string;
	readonly originalMessage: string;
	readonly originalStack: string;
	readonly metadata: Readonly<Metadata> | null | undefined;
	readonly cause: Error | null | undefined;
	/**
	 * Creates an instance of `KindError`.
	 *
	 * @memberof KindError
	 * @param {string} message The error message.
	 * @param {string} [kind] The kind of error. This will be combined with
	 * `prefix` to form the name of the error, i.e. PrefixKindError.
	 * Defaults to `Errors.Unknown`.
	 * @param {Options} [options] Options for constructing the error.
	 * @param {Error} [options.cause] The error that caused this error.
	 * @param {$ReadOnly<Metadata>} [options.metadata] The metadata to attach
	 * to the error.
	 * @param {string} [options.prefix=""] A prefix to prepend the name of the
	 * error.
	 * @param {string} [options.name="Error"] The name of the error.
	 * @param {number} [options.stripStackFrames=0] The number of stack frames
	 * to remove from the error's stack. This can be used to ensure that the top
	 * call of the stack references the point at which an error is thrown which
	 * can be useful when helper functions are used to build the error being
	 * thrown.
	 * @param {number} [options.minimumFrameCount=1] The minimum number of
	 * stack frames to try and retain. This can be used to prevent stripping
	 * all stack frames from the error's stack.
	 * @param {boolean} [options.compositeStack=false] Should we build a
	 * composite stack from the causal error chain or not?
	 */
	constructor(message: string, kind?: string, { cause, prefix, name, metadata, stripStackFrames, minimumFrameCount, compositeStack, }?: Options);
}
/**
 * Options to modify how a safe stringifying operation works.
 */
export type SafeStringifyOptions = {
	/**
	 * A default string to use if the value cannot be stringified.
	 *
	 * @default '""' Empty string
	 * @type {string}
	 */
	defaultValue?: string;
	/**
	 * A number indicating how many spaces to indent nested structures.
	 * When not given, there will be no indentation nor additional newlines.
	 *
	 * @default undefined No indentation
	 * @type {?number}
	 */
	indent?: number | null | undefined;
};
export interface safeStringifyFn {
	/**
	 * Stringify an item, returning an empty string on error, null, or undefined.
	 *
	 * @param {T} value The value to be stringified.
	 * @param {SafeStringifyOptions} [options] Options to modify the output.
	 * @param {string} [options.defaultValue = ""] A default value to return
	 * if the value to be stringified cannot be stringified.
	 * @param {string} [options.indent = undefined] A number indicating how
	 * many spaces to indent nested structures. When specified, values are
	 * stringified over multiple lines indented the specified amount for each
	 * scope of the object.
	 * @returns {string} The stringified value or the default value.
	 */
	<T>(value: T, options?: SafeStringifyOptions): string;
	/**
	 * Stringify an item, returning an empty string on error, null, or undefined.
	 *
	 * @param {T} value The value to be stringified.
	 * @param {string} [defaultValue=""] The default value to return if the value is
	 * null, undefined, or not stringifiable.
	 * @returns {string} The stringified value.
	 */
	<T>(value: T, defaultValue?: string): string;
}
export declare const safeStringify: safeStringifyFn;
/**
 * Truncates a string by replacing the middle with an ellipsis.
 *
 * @export
 * @param {string} str The string to be truncated.
 * @param {number} maxLength The maximum length of a string before it must be
 * truncated.
 * @returns {string} The string, if it is less than or equal to maxLength;
 * otherwise, the string truncated to maxLength - 3 characters with an
 * ellipsis in the middle.
 */
export declare function truncateMiddle(str: string, maxLength: number): string;

export {};
