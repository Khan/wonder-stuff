// @flow
/**
 * Flowtype definitions for wonder-stuff-core
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.21.0
 */

/**
 * Clone a value and all of its nested values.
 *
 * This produces a deep clone of a given value.
 * @param {T} value The value to clone.
 * @returns {T} The cloned value.
 */
declare export var clone: <T>(value: T) => T;
/**
 * Return an array of key/value tuples for an object.
 * @param {$ReadOnly<{[key: K]: V, ...}>} obj The object for which the values are
 * to be returned.
 * @returns {Array<[K, V]>} An array of key/value tuples for the object.
 */
declare export function entries<K: string, V>(
    obj: $ReadOnly<{[key: K]: V, ...}>,
): Array<[K, V]>;

/**
 * Return an array of the enumerable keys of an object.
 * @param {$ReadOnly<{[key: string]: mixed, ...}>} obj The object for which the values are
 * to be returned.
 * @returns {Array<$Keys<O>>} An array of the enumerable keys of an object.
 */
declare export function keys<O: {[key: string]: mixed, ...}>(
    obj: $ReadOnly<O>,
): Array<$Keys<O>>;

/**
 * Return an array of the enumerable property values of an object.
 * @param {ReadOnly<{[key: mixed]: V, ...}>} obj The object for which the values are
 * to be returned.
 * @returns {Array<V>} An array of the enumerable property values of the object.
 */
declare export function values<V>(
    obj: $ReadOnly<{[key: $Keys<$FlowFixMe>]: V, ...}>,
): Array<V>;

/**
 * @typedef Errors A base error taxonomy for consumers of this core
 * library to build off.
 */
/**
 * @type {Errors} A base error taxonomy.
 */
declare export var Errors: $ReadOnly<{
    Unknown: "Unknown",
    Internal: "Internal",
    InvalidInput: "InvalidInput",
    InvalidUse: "InvalidUse",
    ...
}>;
declare export var Order: $ReadOnly<{
    ConsequenceFirst: "consequence-first",
    CauseFirst: "cause-first",
    ...
}>;
export type SequenceOrder = $ElementType<typeof Order, $Keys<typeof Order>>;
/**
 * Given an error, generates a sequence of `Error`s.
 *
 * If the given error is a `KindError`-derivitive, this function will return
 * a sequence starting with that error and then including any causal errors,
 * chaining through causal `KindError`s accordingly.
 *
 * If `reverse` is `true`, the generated sequence starts with the lowermost
 * causal error and ends with the given error.
 */
declare export function errorsFromError(
    error: Error | null | void,
    order: SequenceOrder,
): Iterator<Error>;

/**
 * Get the kind for the given error.
 */
declare export var getKindFromError: (error: Error) => string;
/**
 * Get the original stack trace for the given error.
 */
declare export var getOriginalStackFromError: (error: Error) => string;
export type MetadataPrimitive = string | number | boolean | null | void;
export type MetadataArray<T> = Array<T | MetadataArray<T>>;
/**
 * A collection of data.
 */
export type Metadata = {
    [name: string]:
        | Metadata
        | MetadataPrimitive
        | MetadataArray<MetadataPrimitive | Metadata>,
};
/**
 * Options for constructing a `KindError`.
 */
export type Options = {
    /**
     * An error responsible for the error being created.
     * @type {?Error}
     */
    cause?: Error | null | void,

    /**
     * Data to be attached to the error.
     * @type {?Metadata}
     */
    metadata?: Metadata | null | void,

    /**
     * A prefix for the error name.
     * @type {?string}
     */
    prefix?: string | null | void,

    /**
     * A name for the error.
     * @type {?string}
     */
    name?: string | null | void,

    /**
     * The number of stack frames to strip from the error.
     * @type {?number}
     */
    stripStackFrames?: number | null | void,

    /**
     * The minimum number of stack frames to try and retain.
     * @type {?number}
     */
    minimumFrameCount?: number | null | void,

    /**
     * Should we create a composite stack from the causal error chain or not?
     * @type {?boolean}
     */
    compositeStack?: boolean | null | void,
    ...
};
/**
 * An error to describe detailed states and relationships.
 *
 * This error type supports error taxonomies and attachment of metadata, as
 * well as causal relationships between itself and another source error.
 * More specific variations can be built off this to provide a payload for
 * logging setups like Sentry or winston.
 */
declare export class KindError mixins Error {
    +kind: string;
    +originalMessage: string;
    +originalStack: string;
    +metadata: $ReadOnly<Metadata> | null | void;
    +cause: Error | null | void;

    /**
     * Creates an instance of `KindError`.
     * @memberof KindError
     * @param {string} message The error message.
     * @param {string} [kind] The kind of error. This will be combined with
     * `prefix` to form the name of the error, i.e. PrefixKindError.
     * Defaults to `Errors.Unknown`.
     * @param {Options} [options] Options for constructing the error.
     * @param {Error} [options.cause] The error that caused this error.
     * @param {$ReadOnly<Metadata>} [options.metadata] The metadata to attach
     * to the error.
     * @param {string} [options.prefix] A prefix to prepend the name of the
     * error.
     * @param {string} [options.name] The name of the error.
     * @param {number} [options.stripStackFrames] The number of stack frames
     * to remove from the error's stack. This can be used to ensure that the top
     * call of the stack references the point at which an error is thrown which
     * can be useful when helper functions are used to build the error being
     * thrown.
     * @param {number} [options.minimumFrameCount] The minimum number of
     * stack frames to try and retain. This can be used to prevent stripping
     * all stack frames from the error's stack.
     * @param {boolean} [options.compositeStack] Should we build a
     * composite stack from the causal error chain or not?
     */
    constructor(message: string, kind?: string, x?: Options): this;
}
/**
 * Options to modify how a safe stringifying operation works.
 */
export type SafeStringifyOptions = {
    /**
     * A default string to use if the value cannot be stringified.
     * @default '""' Empty string
     * @type {string}
     */
    defaultValue?: string,

    /**
     * A number indicating how many spaces to indent nested structures.
     * When not given, there will be no indentation nor additional newlines.
     * @default undefined No indentation
     * @type {?number}
     */
    indent?: number | null | void,
    ...
};
export interface safeStringifyFn {
    /**
     * Stringify an item, returning an empty string on error, null, or undefined.
     * @param {T} value The value to be stringified.
     * @param {SafeStringifyOptions} [options] Options to modify the output.
     * @param {string} [options.defaultValue] A default value to return
     * if the value to be stringified cannot be stringified.
     * @param {string} [options.indent] A number indicating how
     * many spaces to indent nested structures. When specified, values are
     * stringified over multiple lines indented the specified amount for each
     * scope of the object.
     * @returns {string} The stringified value or the default value.
     */
    <T>(value: T, options?: SafeStringifyOptions): string;

    /**
     * Stringify an item, returning an empty string on error, null, or undefined.
     * @param {T} value The value to be stringified.
     * @param {string} [defaultValue] The default value to return if the value is
     * null, undefined, or not stringifiable.
     * @returns {string} The stringified value.
     */
    <T>(value: T, defaultValue?: string): string;
}
declare export var safeStringify: safeStringifyFn;
/**
 * Truncates a string by replacing the middle with an ellipsis.
 * @export
 * @param {string} str The string to be truncated.
 * @param {number} maxLength The maximum length of a string before it must be
 * truncated.
 * @returns {string} The string, if it is less than or equal to maxLength;
 * otherwise, the string truncated to maxLength - 3 characters with an
 * ellipsis in the middle.
 */
declare export function truncateMiddle(str: string, maxLength: number): string;
